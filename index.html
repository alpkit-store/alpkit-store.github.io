<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Alpkit Store · Repos</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="./styles.css" />
  <script src="./assets/marked.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="topbar">
      <div class="brand">
        <img src="./assets/logo.png" alt="Alpkit" />
        <div class="title">
          <strong>Alpkit Store</strong>
          <span>Selected repos & public READMEs</span>
        </div>
      </div>
      <div class="header-right">
        <div class="status" id="status"></div>
      </div>
    </div>

    <div class="toolbar">
      <div class="search">
        <input id="q" type="search" placeholder="Filter repos…" autocomplete="off" />
      </div>
      <div class="hint" id="hint"></div>
    </div>

    <div id="list" class="list">Loading…</div>

    <div class="footer">
      READMEs are synced from private repos via GitHub Actions.
      <span class="muted">If you’re missing one, check the repo name in <code>repos.json</code> and whether the sync job ran.</span>
    </div>
  </div>

  <script>
    (function () {
      var ORG = "alpkit-store";
      var LIST = document.getElementById("list");
      var STATUS = document.getElementById("status");
      var Q = document.getElementById("q");
      var HINT = document.getElementById("hint");

      function fetchJSON(path) {
        return fetch(path, { cache: "no-store" }).then(function (res) {
          return res.text().then(function (text) {
            if (!res.ok) throw new Error(path + " -> " + res.status + "\n" + text.slice(0, 300));
            return JSON.parse(text);
          });
        });
      }

      function fetchText(path) {
        return fetch(path, { cache: "no-store" }).then(function (res) {
          if (!res.ok) return null;
          return res.text();
        });
      }

      function headOK(path) {
        return fetch(path, { method: "HEAD", cache: "no-store" })
          .then(function (res) { return res.ok; })
          .catch(function () { return false; });
      }

      // Best-effort "last updated" from Last-Modified header
      function fetchLastModified(path) {
        return fetch(path, { method: "HEAD", cache: "no-store" }).then(function (res) {
          if (!res.ok) return null;
          var lm = res.headers.get("last-modified");
          return lm ? new Date(lm) : null;
        }).catch(function () {
          return null;
        });
      }

      // Basic HTML sanitization (not as strong as DOMPurify, but helps)
      function sanitizeHTML(html) {
        try {
          var doc = new DOMParser().parseFromString(html, "text/html");

          Array.prototype.slice.call(doc.querySelectorAll("script")).forEach(function (n) {
            n.parentNode.removeChild(n);
          });

          Array.prototype.slice.call(doc.querySelectorAll("*")).forEach(function (el) {
            Array.prototype.slice.call(el.attributes || []).forEach(function (attr) {
              var name = (attr.name || "").toLowerCase();
              var value = (attr.value || "").trim();

              if (name.startsWith("on")) el.removeAttribute(attr.name);
              if ((name === "href" || name === "src") && /^javascript:/i.test(value)) el.removeAttribute(attr.name);
            });
          });

          return doc.body.innerHTML || "";
        } catch (e) {
          return "";
        }
      }

      function renderError(err) {
        LIST.innerHTML = "<pre class='error'>" + String(err && err.message ? err.message : err) + "</pre>";
      }

      function setStatus(total, shown) {
        STATUS.textContent = "Showing " + shown + " of " + total;
      }

      if (typeof window.marked === "undefined") {
        renderError("marked is undefined (script failed to load)");
        return;
      }

      try {
        window.marked.setOptions({ mangle: false, headerIds: false });
      } catch (e) {}

      LIST.textContent = "Loading…";

      fetchJSON("./repos.json").then(function (cfg) {
        var repos = (cfg && cfg.repos) ? cfg.repos.slice() : [];
        if (!repos.length) {
          LIST.innerHTML = "<em>No repos listed in repos.json</em>";
          setStatus(0, 0);
          return;
        }

        var checks = repos.map(function (name) {
          var readmePath = "./readmes/" + name + "/README.md";
          return headOK(readmePath).then(function (ok) {
            return { name: name, readmePath: readmePath, exists: ok };
          });
        });

        Promise.all(checks).then(function (results) {
          var existing = results.filter(function (r) { return r.exists; });
          var display = existing.length ? existing : results;

          setStatus(repos.length, display.length);
          HINT.textContent = existing.length ? "" : "No synced READMEs found yet (showing all repos so you can check names).";

          function buildList(filterText) {
            var ft = (filterText || "").toLowerCase().trim();
            LIST.innerHTML = "";

            var filtered = display.filter(function (r) {
              return !ft || r.name.toLowerCase().indexOf(ft) !== -1;
            });

            if (!filtered.length) {
              LIST.innerHTML = "<em>No matches.</em>";
              return;
            }

            filtered.forEach(function (r) {
              var name = r.name;
              var readmePath = r.readmePath;

              var d = document.createElement("details");
              d.className = "card";

              var summary = document.createElement("summary");
              summary.textContent = name;
              d.appendChild(summary);

              var links = document.createElement("div");
              links.className = "links";

              var aRepo = document.createElement("a");
              aRepo.href = "https://github.com/" + ORG + "/" + name;
              aRepo.target = "_blank";
              aRepo.rel = "noreferrer";
              aRepo.textContent = "Open repo";

              var aMd = document.createElement("a");
              aMd.href = readmePath;
              aMd.target = "_blank";
              aMd.rel = "noreferrer";
              aMd.textContent = "View synced README.md";

              var badge = document.createElement("span");
              badge.className = "badge";
              badge.textContent = "Last updated: …";

              links.appendChild(aRepo);
              links.appendChild(document.createTextNode(" · "));
              links.appendChild(aMd);
              links.appendChild(document.createTextNode(" · "));
              links.appendChild(badge);
              d.appendChild(links);

              var readme = document.createElement("div");
              readme.className = "readme";
              readme.innerHTML = "<em>Expand to load README…</em>";
              d.appendChild(readme);

              fetchLastModified(readmePath).then(function (dt) {
                badge.textContent = dt ? ("Last updated: " + dt.toLocaleString()) : "Last updated: unknown";
              });

              d.addEventListener("toggle", function () {
                if (!d.open) return;
                if (readme.dataset.loaded) return;

                readme.innerHTML = "<em>Loading…</em>";

                fetchText(readmePath).then(function (md) {
                  if (!md) {
                    readme.innerHTML = "<em>No README at " + readmePath + "</em>";
                    readme.dataset.loaded = "1";
                    return;
                  }

                  var html = window.marked.parse(md);
                  var safe = sanitizeHTML(html);

                  if (!safe) {
                    // Fallback to plain text
                    readme.innerHTML = "<pre></pre>";
                    readme.querySelector("pre").textContent = md;
                  } else {
                    readme.innerHTML = safe;
                  }

                  readme.dataset.loaded = "1";
                }).catch(function (err) {
                  readme.innerHTML = "<pre class='error'>" + String(err && err.message ? err.message : err) + "</pre>";
                });
              });

              LIST.appendChild(d);
            });
          }

          buildList("");
          Q.addEventListener("input", function () { buildList(Q.value); });
        }).catch(renderError);
      }).catch(renderError);
    })();
  </script>
</body>
</html>
